const { NotFound } = require('../sdk/web/backing/error-template');

const pkiUtils = require('../core/pki-utils');
/**
 * Service to handle certificates
 */
class CertificatesService {
  /**
   * The dependencies are injected through the constructor
   */
  constructor({
    db, ejbcaFacade, tenant, dnUtils, logger, certValidity,
    checkPublicKey, queryMaxTimeMS,
  }) {
    this.db = db;
    this.ejbcaFacade = ejbcaFacade;
    this.tenant = tenant;
    this.dnUtils = dnUtils;
    this.logger = logger;
    this.certValidity = certValidity;
    this.checkPublicKey = checkPublicKey;
    this.queryMaxTimeMS = queryMaxTimeMS;
    this.CertificateModel = db.certificate.model;
    this.notImplemented = 'This operation is not available yet';
  }

  /**
   * Generates an x509 certificate based on a CSR
   *
   * @param {object} Object with the CSR and data whom the certificate is to be associated.
   *
   * @returns an object containing the certificate in PEM format and its fingerprint.
   */
  async generateCertificate({ csr: csrPem, belongsTo }) {
    const csr = pkiUtils.parseCSR(csrPem);

    if (this.checkPublicKey) {
      pkiUtils.checkPublicKey(csr.subjectPublicKeyInfo);
    }

    const subjectDN = this.dnUtils.from(csr.subject)
      .verify()
      .cnamePrefix(this.tenant)
      .stringify();

    const certificatePem = await this.ejbcaFacade.generateCertificate(
      subjectDN, this.certValidity, csrPem,
    );

    const certificateFingerprint = pkiUtils.getFingerprint(certificatePem);

    const model = new this.CertificateModel({
      fingerprint: certificateFingerprint,
      pem: certificatePem,
      belongsTo,
      tenant: this.tenant,
    });
    await model.save();

    return { certificateFingerprint, certificatePem };
  }

  /**
   * Register an external certificate (not generated by this service)
   */
  async registerCertificate(/* { certificatePem, belongsTo } */) {
    await Promise.reject(NotFound(this.notImplemented));
  }

  /**
   * Changes the one that is associated with a certificate
   *
   * @param {object} filterFields Filter fields to find the correct certificate in the database
   * @param {object} belongsTo Data of whom the certificate should be associated
   *
   * @throws an exception if no record is found with the entered filters.
   */
  async changeOwnership(filterFields, belongsTo) {
    const result = await this.CertificateModel.findOneAndUpdate(filterFields, { belongsTo })
      .maxTimeMS(this.queryMaxTimeMS)
      .exec();
    if (!result) {
      throw NotFound(`No records found for the following parameters: ${JSON.stringify(filterFields)}`);
    }
  }

  /**
   * Retrieves a certificate from the database
   *
   * @param {object} queryFields Certificate fields that must be returned in the record
   * @param {object} filterFields Filter fields to find the correct certificate in the database
   *
   * @returns Returns the record that represents the certificate in the database
   *
   * @throws an exception if no record is found with the entered filters.
   */
  async getCertificate(queryFields, filterFields) {
    /* Executes the query and converts the result to JSON */
    const result = await this.CertificateModel.findOne(filterFields)
      .select(queryFields.join(' '))
      .maxTimeMS(this.queryMaxTimeMS)
      .lean()
      .exec();
    if (!result) {
      throw NotFound(`No records found for the following parameters: ${JSON.stringify(filterFields)}`);
    }
    return result;
  }

  /**
   * Retrieves from the database a set of certificates that meet the search criteria
   *
   * @param {object} queryFields Certificate fields that must be returned in each record
   * @param {object} filterFields Filter fields to find the correct certificates in the database
   * @param {number} limit Limit of records that must be returned
   * @param {number} offset Offset in relation to the first record found by the query
   *
   * @returns a set of certificates that meet the search criteria
   */
  async listCertificates(queryFields, filterFields, limit, offset) {
    /* Executes the query and converts the results to JSON */
    const [results, itemCount] = await Promise.all([
      this.CertificateModel.find(filterFields)
        .select(queryFields.join(' '))
        .limit(limit).skip(offset)
        .maxTimeMS(this.queryMaxTimeMS)
        .lean()
        .exec(),
      this.CertificateModel.countDocuments(filterFields),
    ]);
    return { itemCount, results };
  }

  /**
   * Removes a certificate from the database.
   * If the certificate was generated by this service,
   * then it will also be revoked in a CRL.
   *
   * @param {object} certRecord Record that represents the certificate in
   *                       the database and that must be removed.
   */
  async deleteCertificate(certRecord) {
    /* eslint no-underscore-dangle: ["error", { "allow": ["_id"] }] */
    await this.CertificateModel.findByIdAndDelete(certRecord._id)
      .maxTimeMS(this.queryMaxTimeMS)
      .exec();

    /* If the certificate was issued by the internal CA,
     * it must be revoked in a Certificate Revocation List */
    if (certRecord.issuedByDojotPki) {
      const cert = pkiUtils.parseCert(certRecord.pem);
      const issuerDN = this.dnUtils.from(cert.issuer).stringify();
      const certificateSN = pkiUtils.getSerialNumber(cert);
      await this.ejbcaFacade.revokeCertificate(issuerDN, certificateSN);
    }
  }

  /**
   * It literally throws away a certificate, that is, it generates a certificate,
   * but does not keep a record for it.
   * This is used by internal services that need a certificate to establish a
   * mutual TLS with other parties.
   * @param {object} Object with a CSR that will serve as the basis for generating the certificate.
   *
   * @returns an object containing the certificate in PEM format and its fingerprint.
   */
  async throwAwayCertificate({ csr: csrPem }) {
    const csr = pkiUtils.parseCSR(csrPem);

    const subjectDN = this.dnUtils.from(csr.subject).stringify();

    const certificatePem = await this.ejbcaFacade.generateCertificate(
      subjectDN, this.certValidity, csrPem,
    );

    const certificateFingerprint = pkiUtils.getFingerprint(certificatePem);

    return { certificateFingerprint, certificatePem };
  }
}

module.exports = CertificatesService;
